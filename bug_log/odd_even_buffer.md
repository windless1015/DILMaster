# Bug 分析：液体飞天案

## 1. 核心机制：双缓冲 (Double Buffering)
在格子玻尔兹曼方法 (LBM) 模拟中，我们跟踪粒子分布函数 ($f$)。为了在 GPU 上并行化处理，我们使用 **双缓冲技术**：
- **缓冲 A**: $t$ 时刻的状态
- **缓冲 B**: $t+1$ 时刻的状态

我们要根据步数的奇偶性在这些缓冲区之间切换：
- **偶数步 ($t=0, 2, ...$)**: 从 **A** 读，写到 **B**
- **奇数步 ($t=1, 3, ...$)**: 从 **B** 读，写到 **A**

## 2. 实现现状
LBM 核心 (`LBMCore`) 维护了一个 **内部计数器** (`stepCount_`) 来跟踪这种奇偶性。
自由表面模块 (`FreeSurfaceModule`) 则依赖于传入的 **外部上下文** (`ctx.step`) 来判断处理方向（比如质量交换的方向）。

### 代码状态（修复前）

**LBMCore** (内部状态)
- 初始化后: `stepCount_ = 0` (偶数)
- 预期行为: "我准备执行第 0 步。我将读取缓冲 A，写入缓冲 B。"

**ScenarioRunner** (驱动循环)
```cpp
// 循环从 1 开始
for (int step = 1; step <= spec.steps; ++step) {
  ctx.step = step; // ctx.step 变成了 1 (奇数)
  solver.step(ctx); 
}
```

## 3. 冲突点

当 `solver.step(ctx)` **第一次** 运行时：

1.  **自由表面预流 (Pre-Stream) (`module->preStream(ctx)`)**
    - 接收到 `ctx.step = 1`。
    - 认为: "这是奇数步。我应该从 **缓冲 B** (奇数步的'读'缓冲) 捕获流出质量。"
    - **现实**: 缓冲 B 此时是未初始化的，或者包含垃圾数据，因为我们还没计算第 0 步！

2.  **LBM 流碰撞 (Streaming) (`core_->streamCollide()`)**
    - 使用内部 `stepCount_ = 0`。
    - 认为: "这是偶数步。我将从 **缓冲 A** 流向 缓冲 B。"
    - **现实**: 对纯流体来说这一步是正确的，但是...

3.  **自由表面后流 (Post-Stream) (`module->postStream(ctx)`)**
     - 接收到 `ctx.step = 1`。
     - 认为: "奇数步。我将根据流碰撞结果更新 Flag 和质量。"
     - **致命错误**: 它试图将之前从缓冲 B (垃圾数据) 捕获的质量与从缓冲 A 流过来的有效流体进行调和。

## 4. 物理表现
由于自由表面模块读取了错误的缓冲区（本质上是读取了本该用于写入的“未来”缓冲区或垃圾内存），它计算出了极其错误的质量通量。

- **质量凭空产生**: 它看到了“无中生有”的质量。
- **速度噪声**:由于各个方向分布函数不匹配，界面处重建了错误的宏观速度。

这导致液体界面瞬间“爆炸”或向上飞起 (+Z 方向)，因为数值误差在一步之内就急剧累积。

## 5. 解决方案
我们需要“对齐时钟”。通过在 Runner 中设置 `ctx.step = step - 1`，我们确保当 `LBMCore` 认为是第 0 步 (偶数) 时，`FreeSurfaceModule` 也接收到第 0 步 (偶数)。

```cpp
// ScenarioRunner.cpp
- ctx.step = step;      // 1 vs 0 (不匹配!)
+ ctx.step = step - 1;  // 0 vs 0 (匹配!)